.. _Programmer_Specific_Information:

*******************************
Programmer Specific Information
*******************************


.. _Atmel_STK600:

Atmel STK600
============

The following devices are supported by the respective STK600 routing
and socket card:

@multitable @columnfractions .25 .25 .5
@headitem Routing card @tab Socket card @tab Devices
* `} @tab @code{STK600-ATTINY10` @tab ATtiny4 ATtiny5 ATtiny9 ATtiny10
* `STK600-RC008T-2` @tab `STK600-DIP` @tab ATtiny11 ATtiny12 ATtiny13 ATtiny13A ATtiny25 ATtiny45 ATtiny85
* `STK600-RC008T-7` @tab `STK600-DIP` @tab ATtiny15
* `STK600-RC014T-42` @tab `STK600-SOIC` @tab ATtiny20
* `STK600-RC020T-1` @tab `STK600-DIP` @tab ATtiny2313 ATtiny2313A ATtiny4313
* `} @tab @code{STK600-TinyX3U` @tab ATtiny43U
* `STK600-RC014T-12` @tab `STK600-DIP` @tab ATtiny24 ATtiny44 ATtiny84 ATtiny24A ATtiny44A
* `STK600-RC020T-8` @tab `STK600-DIP` @tab ATtiny26 ATtiny261 ATtiny261A ATtiny461 ATtiny861 ATtiny861A
* `STK600-RC020T-43` @tab `STK600-SOIC` @tab ATtiny261 ATtiny261A ATtiny461 ATtiny461A ATtiny861 ATtiny861A
* `STK600-RC020T-23` @tab `STK600-SOIC` @tab ATtiny87 ATtiny167
* `STK600-RC028T-3` @tab `STK600-DIP` @tab ATtiny28
* `STK600-RC028M-6` @tab `STK600-DIP` @tab ATtiny48 ATtiny88 ATmega8 ATmega8A ATmega48 ATmega88 ATmega168 ATmega48P ATmega48PA ATmega88P ATmega88PA ATmega168P ATmega168PA ATmega328P
* `} @tab @code{QT600-ATTINY88-QT8` @tab ATtiny88
* `STK600-RC040M-4` @tab `STK600-DIP` @tab ATmega8515 ATmega162
* `STK600-RC044M-30` @tab `STK600-TQFP44` @tab ATmega8515 ATmega162
* `STK600-RC040M-5` @tab `STK600-DIP` @tab ATmega8535 ATmega16 ATmega16A ATmega32 ATmega32A ATmega164P ATmega164PA ATmega324P ATmega324PA ATmega644 ATmega644P ATmega644PA ATmega1284P
* `STK600-RC044M-31` @tab `STK600-TQFP44` @tab ATmega8535 ATmega16 ATmega16A ATmega32 ATmega32A ATmega164P ATmega164PA ATmega324P ATmega324PA ATmega644 ATmega644P ATmega644PA ATmega1284P
* `} @tab @code{QT600-ATMEGA324-QM64` @tab ATmega324PA
* `STK600-RC032M-29` @tab `STK600-TQFP32` @tab ATmega8 ATmega8A ATmega48 ATmega88 ATmega168 ATmega48P ATmega48PA ATmega88P ATmega88PA ATmega168P ATmega168PA ATmega328P
* `STK600-RC064M-9` @tab `STK600-TQFP64` @tab ATmega64 ATmega64A ATmega128 ATmega128A ATmega1281 ATmega2561 AT90CAN32 AT90CAN64 AT90CAN128
* `STK600-RC064M-10` @tab `STK600-TQFP64` @tab ATmega165 ATmega165P ATmega169 ATmega169P ATmega169PA ATmega325 ATmega325P ATmega329 ATmega329P ATmega645 ATmega649 ATmega649P
* `STK600-RC100M-11` @tab `STK600-TQFP100` @tab ATmega640 ATmega1280 ATmega2560
* `} @tab @code{STK600-ATMEGA2560` @tab ATmega2560
* `STK600-RC100M-18` @tab `STK600-TQFP100` @tab ATmega3250 ATmega3250P ATmega3290 ATmega3290P ATmega6450 ATmega6490
* `STK600-RC032U-20` @tab `STK600-TQFP32` @tab AT90USB82 AT90USB162 ATmega8U2 ATmega16U2 ATmega32U2
* `STK600-RC044U-25` @tab `STK600-TQFP44` @tab ATmega16U4 ATmega32U4
* `STK600-RC064U-17` @tab `STK600-TQFP64` @tab ATmega32U6 AT90USB646 AT90USB1286 AT90USB647 AT90USB1287
* `STK600-RCPWM-22` @tab `STK600-TQFP32` @tab ATmega32C1 ATmega64C1 ATmega16M1 ATmega32M1 ATmega64M1
* `STK600-RCPWM-19` @tab `STK600-SOIC` @tab AT90PWM2 AT90PWM3 AT90PWM2B AT90PWM3B AT90PWM216 AT90PWM316
* `STK600-RCPWM-26` @tab `STK600-SOIC` @tab AT90PWM81
* `STK600-RC044M-24` @tab `STK600-TSSOP44` @tab ATmega16HVB ATmega32HVB
* `} @tab @code{STK600-HVE2` @tab ATmega64HVE
* `} @tab @code{STK600-ATMEGA128RFA1` @tab ATmega128RFA1
* `STK600-RC100X-13` @tab `STK600-TQFP100` @tab ATxmega64A1 ATxmega128A1 ATxmega128A1_revD ATxmega128A1U
* `} @tab @code{STK600-ATXMEGA1281A1` @tab ATxmega128A1
* `} @tab @code{QT600-ATXMEGA128A1-QT16` @tab ATxmega128A1
* `STK600-RC064X-14` @tab `STK600-TQFP64` @tab ATxmega64A3 ATxmega128A3 ATxmega256A3 ATxmega64D3 ATxmega128D3 ATxmega192D3 ATxmega256D3
* `STK600-RC064X-14` @tab `STK600-MLF64` @tab ATxmega256A3B
* `STK600-RC044X-15` @tab `STK600-TQFP44` @tab ATxmega32A4 ATxmega16A4 ATxmega16D4 ATxmega32D4
* `} @tab @code{STK600-ATXMEGAT0` @tab ATxmega32T0
* `} @tab @code{STK600-uC3-144` @tab AT32UC3A0512 AT32UC3A0256 AT32UC3A0128
* `STK600-RCUC3A144-33` @tab `STK600-TQFP144` @tab AT32UC3A0512 AT32UC3A0256 AT32UC3A0128
* `STK600-RCuC3A100-28` @tab `STK600-TQFP100` @tab AT32UC3A1512 AT32UC3A1256 AT32UC3A1128
* `STK600-RCuC3B0-21` @tab `STK600-TQFP64-2` @tab AT32UC3B0256 AT32UC3B0512RevC AT32UC3B0512 AT32UC3B0128 AT32UC3B064 AT32UC3D1128
* `STK600-RCuC3B48-27` @tab `STK600-TQFP48` @tab AT32UC3B1256 AT32UC3B164
* `STK600-RCUC3A144-32` @tab `STK600-TQFP144` @tab AT32UC3A3512 AT32UC3A3256 AT32UC3A3128 AT32UC3A364 AT32UC3A3256S AT32UC3A3128S AT32UC3A364S
* `STK600-RCUC3C0-36` @tab `STK600-TQFP144` @tab AT32UC3C0512 AT32UC3C0256 AT32UC3C0128 AT32UC3C064
* `STK600-RCUC3C1-38` @tab `STK600-TQFP100` @tab AT32UC3C1512 AT32UC3C1256 AT32UC3C1128 AT32UC3C164
* `STK600-RCUC3C2-40` @tab `STK600-TQFP64-2` @tab AT32UC3C2512 AT32UC3C2256 AT32UC3C2128 AT32UC3C264
* `STK600-RCUC3C0-37` @tab `STK600-TQFP144` @tab AT32UC3C0512 AT32UC3C0256 AT32UC3C0128 AT32UC3C064
* `STK600-RCUC3C1-39` @tab `STK600-TQFP100` @tab AT32UC3C1512 AT32UC3C1256 AT32UC3C1128 AT32UC3C164
* `STK600-RCUC3C2-41` @tab `STK600-TQFP64-2` @tab AT32UC3C2512 AT32UC3C2256 AT32UC3C2128 AT32UC3C264
* `STK600-RCUC3L0-34` @tab `STK600-TQFP48` @tab AT32UC3L064 AT32UC3L032 AT32UC3L016
* `} @tab @code{QT600-AT32UC3L-QM64` @tab AT32UC3L064
@end multitable

Ensure the correct socket and routing card are mounted *before*
powering on the STK600.  While the STK600 firmware ensures the socket
and routing card mounted match each other (using a table stored
internally in nonvolatile memory), it cannot handle the case where a
wrong routing card is used, e. g. the routing card
`STK600-RC040M-5` (which is meant for 40-pin DIP AVRs that have
an ADC, with the power supply pins in the center of the package) was
used but an ATmega8515 inserted (which uses the 'industry standard'
pinout with Vcc and GND at opposite corners).

Note that for devices that use the routing card `STK600-RC008T-2`,
in order to use ISP mode, the jumper for `AREF0` must be removed
as it would otherwise block one of the ISP signals.  High-voltage
serial programming can be used even with that jumper installed.

The ISP system of the STK600 contains a detection against shortcuts
and other wiring errors.  AVRDUDE initiates a connection check before
trying to enter ISP programming mode, and display the result if the
target is not found ready to be ISP programmed.

High-voltage programming requires the target voltage to be set to at
least 4.5 V in order to work.  This can be done using
*Terminal Mode*, see :ref:`Terminal_Mode_Operation`.

.. _Atmel_DFU_bootloader_using_FLIP_version_1:

Atmel DFU bootloader using FLIP version 1
=========================================

Bootloaders using the FLIP protocol version 1 experience some very
specific behaviour.

These bootloaders have no option to access memory areas other than
Flash and EEPROM.

When the bootloader is started, it enters a *security mode* where
the only acceptable access is to query the device configuration
parameters (which are used for the signature on AVR devices).  The
only way to leave this mode is a *chip erase*.  As a chip erase
is normally implied by the *-U* option when reprogramming the
flash, this peculiarity might not be very obvious immediately.

Sometimes, a bootloader with security mode already disabled seems to
no longer respond with sensible configuration data, but only 0xFF for
all queries.  As these queries are used to obtain the equivalent of a
signature, AVRDUDE can only continue in that situation by forcing the
signature check to be overridden with the *-F* option.

A *chip erase* might leave the EEPROM unerased, at least on some
versions of the bootloader.

.. _SerialUPDI_programmer:

SerialUPDI programmer
=====================

SerialUPDI programmer can be used for programming UPDI-only devices
using very simple serial connection.
You can read more about the details here 
`https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md <https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md>`_

SerialUPDI programmer has been tested using FT232RL USB->UART interface
with the following connection layout (copied from Spence Kohde's page linked
above):

::

  --------------------                                 To Target device
                  DTR|                                  __________________
                  Rx |--------------,------------------| UPDI---\\/\\/---------->
    Tx---/\\/\\/\\---Tx |-------|<|---'          .--------| Gnd    470 ohm 
      resistor    Vcc|---------------------------------| Vcc
          1k      CTS|                     .`          |__________________
                  Gnd|--------------------' 
  --------------------
  

There are several limitations in current SerialUPDI/AVRDUDE integration,
listed below.

At the end of each run there are fuse values being presented to the user.
For most of the UPDI-enabled devices these definitions (low fuse, high
fuse, extended fuse) have no meaning whatsoever, as they have been 
simply replaced by array of fuses: fuse0..9. Therefore you can simply
ignore this particular line of AVRDUDE output.

In connection to the above, *safemode* has no meaning in context
of UPDI devices and should be ignored.

Currently available devices support only UPDI NVM programming model 0 
and 2, but there is also experimental implementation of model 3 - not
yet tested.

One of the core AVRDUDE features is verification of the connection by
reading device signature prior to any operation, but this operation
is not possible on UPDI locked devices. Therefore, to be able to 
connect to such a device, you have to provide *-F* to override
this check.

Please note: using *-F* during write operation to locked device 
will force chip erase. Use carefully.

Another issue you might notice is slow performance of EEPROM writing
using SerialUPDI for AVR Dx devices. This can be addressed by changing
*avrdude.conf* section for this device - changing EEPROM page 
size to 0x20 (instead of default 1), like so:

::

  #------------------------------------------------------------
  # AVR128DB28
  #------------------------------------------------------------

  part parent    ".avrdx"
      id        = "avr128db28";
      desc      = "AVR128DB28";
      signature = 0x1E 0x97 0x0E;

      memory "flash"
          size      = 0x20000;
          offset    = 0x800000;
          page_size = 0x200;
          readsize  = 0x100;
      ;

      memory "eeprom"
          size      = 0x200;
          offset    = 0x1400;
          page_size = 0x1;
          readsize  = 0x100;
      ;
  ;
  

USERROW memory has not been defined for new devices except for 
experimental addition for AVR128DB28. The point of USERROW is to 
provide ability to write configuration details to already locked
device and currently SerialUPDI interface supports this feature,
but it hasn't been tested on wide variety of chips. Treat this as
something experimental at this point. Please note: on locked devices
it's not possible to read back USERROW contents when written, so
the automatic verification will most likely fail and to prevent
error messages, use *-V*.

Please note that SerialUPDI interface is pretty new and some
issues are to be expected. In case you run into them, please
make sure to run the intended command with debug output enabled
(*-v -v -v*) and provide this verbose output with your
bug report. You can also try to perform the same action using
*pymcuprog* (`https://github.com/microchip-pic-avr-tools/pymcuprog <https://github.com/microchip-pic-avr-tools/pymcuprog>`_)
utility with *-v debug* and provide its output too.
You will notice that both outputs are pretty similar, and this
was implemented like that on purpose - it was supposed to make
analysis of UPDI protocol quirks easier.

@appendix Platform Dependent Information

.. _Unix:

Unix
====


.. _Unix_Installation:

Unix Installation
-----------------

To build and install from the source tarball on Unix like systems:

::

  $ gunzip -c avrdude-6.99-20211218.tar.gz | tar xf -
  $ cd avrdude-6.99-20211218
  $ ./configure
  $ make
  $ su root -c 'make install'
  

The default location of the install is into `/usr/local` so you
will need to be sure that `/usr/local/bin` is in your `PATH`
environment variable.

If you do not have root access to your system, you can do the
following instead:

::

  $ gunzip -c avrdude-6.99-20211218.tar.gz | tar xf -
  $ cd avrdude-6.99-20211218
  $ ./configure --prefix=$HOME/local
  $ make
  $ make install
  

.. _FreeBSD_Installation:

FreeBSD Installation
^^^^^^^^^^^^^^^^^^^^

AVRDUDE is installed via the FreeBSD Ports Tree as follows:

::

  % su - root
  # cd /usr/ports/devel/avrdude
  # make install
  

If you wish to install from a pre-built package instead of the source,
you can use the following instead:

::

  % su - root
  # pkg_add -r avrdude
  

Of course, you must be connected to the Internet for these methods to
work, since that is where the source as well as the pre-built package is
obtained.

.. _Linux_Installation:

Linux Installation
^^^^^^^^^^^^^^^^^^

On rpm based Linux systems (such as RedHat, SUSE, Mandrake, etc.), you
can build and install the rpm binaries directly from the tarball:

::

  $ su - root
  # rpmbuild -tb avrdude-6.99-20211218.tar.gz
  # rpm -Uvh /usr/src/redhat/RPMS/i386/avrdude-6.99-20211218-1.i386.rpm
  

Note that the path to the resulting rpm package, differs from system
to system. The above example is specific to RedHat.

.. _Unix_Configuration_Files:

Unix Configuration Files
------------------------

When AVRDUDE is build using the default *--prefix* configure
option, the default configuration file for a Unix system is located at
`/usr/local/etc/avrdude.conf`.  This can be overridden by using the
*-C* command line option.  Additionally, the user's home directory
is searched for a file named `.avrduderc`, and if found, is used to
augment the system default configuration file.

.. _FreeBSD_Configuration_Files:

FreeBSD Configuration Files
^^^^^^^^^^^^^^^^^^^^^^^^^^^

When AVRDUDE is installed using the FreeBSD ports system, the system
configuration file is always `/usr/local/etc/avrdude.conf`.

.. _Linux_Configuration_Files:

Linux Configuration Files
^^^^^^^^^^^^^^^^^^^^^^^^^

When AVRDUDE is installed using from an rpm package, the system
configuration file will be always be `/etc/avrdude.conf`.

.. _Unix_Port_Names:

Unix Port Names
---------------

The parallel and serial port device file names are system specific.
The following table lists the default names for a given system.

@multitable @columnfractions .30 .30 .30
* @strong{System}
@tab @strong{Default Parallel Port}
@tab @strong{Default Serial Port}
* FreeBSD
@tab `/dev/ppi0`
@tab `/dev/cuad0`
* Linux
@tab `/dev/parport0`
@tab `/dev/ttyS0`
* Solaris
@tab `/dev/printers/0`
@tab `/dev/term/a`
@end multitable

On FreeBSD systems, AVRDUDE uses the ppi(4) interface for
accessing the parallel port and the sio(4) driver for serial port
access.

On Linux systems, AVRDUDE uses the ppdev interface for
accessing the parallel port and the tty driver for serial port
access.

On Solaris systems, AVRDUDE uses the ecpp(7D) driver for
accessing the parallel port and the asy(7D) driver for serial port
access.

.. _Unix_Documentation:

Unix Documentation
------------------

AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
`/usr/local/man/man1` area, while the HTML and PDF documentation
is installed in `/usr/local/share/doc/avrdude` directory.  The
info manual is installed in `/usr/local/info/avrdude.info`.

Note that these locations can be altered by various configure options
such as *--prefix*.

.. _Windows:

Windows
=======


.. _Installation:

Installation
------------

A Windows executable of avrdude is included in WinAVR which can be found at
`http://sourceforge.net/projects/winavr <http://sourceforge.net/projects/winavr>`_. WinAVR is a suite of executable, 
open source software development tools for the AVR for the Windows platform.

There are two options to build avrdude from source under Windows.
The first one is to use Cygwin (`http://www.cygwin.com/ <http://www.cygwin.com/>`_).

To build and install from the source tarball for Windows (using Cygwin):

::

  $ set PREFIX=<your install directory path>
  $ export PREFIX
  $ gunzip -c avrdude-6.99-20211218.tar.gz | tar xf -
  $ cd avrdude-6.99-20211218
  $ ./configure LDFLAGS="-static" --prefix=$PREFIX --datadir=$PREFIX 
  --sysconfdir=$PREFIX/bin --enable-versioned-doc=no
  $ make
  $ make install
  

Note that recent versions of Cygwin (starting with 1.7) removed the
MinGW support from the compiler that is needed in order to build a
native Win32 API binary that does not require to install the Cygwin
library `cygwin1.dll` at run-time.  Either try using an older
compiler version that still supports MinGW builds, or use MinGW
(`http://www.mingw.org/ <http://www.mingw.org/>`_) directly.

.. _Configuration_Files:

Configuration Files
-------------------


.. _Configuration_file_names:

Configuration file names
^^^^^^^^^^^^^^^^^^^^^^^^

AVRDUDE on Windows looks for a system configuration file name of
`avrdude.conf` and looks for a user override configuration file of
`avrdude.rc`.

.. _How_AVRDUDE_finds_the_configuration_files.:

How AVRDUDE finds the configuration files.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

AVRDUDE on Windows has a different way of searching for the system and
user configuration files. Below is the search method for locating the
configuration files:


* 
  Only for the system configuration file:
  `<directory from which application loaded>/../etc/avrdude.conf`

* 
  The directory from which the application loaded.

* 
  The current directory.

* 
  The Windows system directory. On Windows NT, the name of this directory
  is `SYSTEM32`.

* 
  Windows NT: The 16-bit Windows system directory. The name of this
  directory is `SYSTEM`.

* 
  The Windows directory.

* 
  The directories that are listed in the PATH environment variable.


.. _Port_Names:

Port Names
----------


.. _Serial_Ports:

Serial Ports
^^^^^^^^^^^^

When you select a serial port (i.e. when using an STK500) use the
Windows serial port device names such as: com1, com2, etc.

.. _Parallel_Ports:

Parallel Ports
^^^^^^^^^^^^^^

AVRDUDE will accept 3 Windows parallel port names: lpt1, lpt2, or
lpt3.  Each of these names corresponds to a fixed parallel port base
address:



*lpt1*
  0x378


*lpt2*
  0x278


*lpt3*
  0x3BC


On your desktop PC, lpt1 will be the most common choice. If you are
using a laptop, you might have to use lpt3 instead of lpt1. Select the
name of the port the corresponds to the base address of the parallel
port that you want.

If the parallel port can be accessed through a different
address, this address can be specified directly, using the common C
language notation (i. e., hexadecimal values are prefixed by `0x`).

Documentation
-------------

AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
`/usr/local/man/man1` area, while the HTML and PDF documentation
is installed in `/usr/local/share/doc/avrdude` directory.  The
info manual is installed in `/usr/local/info/avrdude.info`.

Note that these locations can be altered by various configure options
such as *--prefix* and *--datadir*.

@appendix Troubleshooting

In general, please report any bugs encountered via
@*
`http://savannah.nongnu.org/bugs/?group=avrdude <http://savannah.nongnu.org/bugs/?group=avrdude>`_.


* 
  Problem: I'm using a serial programmer under Windows and get the following
  error:

  `avrdude: serial_open(): can't set attributes for device "com1"`,

  Solution: This problem seems to appear with certain versions of Cygwin. Specifying
  `"/dev/com1"` instead of `"com1"` should help.

* 
  Problem: I'm using Linux and my AVR910 programmer is really slow.

  Solution (short): `setserial `port` low_latency`

  Solution (long):
  There are two problems here. First, the system may wait some time before it
  passes data from the serial port to the program. Under Linux the following
  command works around this (you may need root privileges for this).

  `setserial `port` low_latency`

  Secondly, the serial interface chip may delay the interrupt for some time.
  This behaviour can be changed by setting the FIFO-threshold to one. Under Linux this
  can only be done by changing the kernel source in `drivers/char/serial.c`.
  Search the file for `UART_FCR_TRIGGER_8` and replace it with `UART_FCR_TRIGGER_1`. Note that overall performance might suffer if there
  is high throughput on serial lines. Also note that you are modifying the kernel at
  your own risk.

* 
  Problem: I'm not using Linux and my AVR910 programmer is really slow.

  Solutions: The reasons for this are the same as above.
  If you know how to work around this on your OS, please let us know.

* 
  Problem: Updating the flash ROM from terminal mode does not work with the
  JTAG ICEs.

  Solution: None at this time.  Currently, the JTAG ICE code cannot
  write to the flash ROM one byte at a time.

* 
  Problem: Page-mode programming the EEPROM (using the -U option) does
  not erase EEPROM cells before writing, and thus cannot overwrite any
  previous value != 0xff.

  Solution: None.  This is an inherent feature of the way JTAG EEPROM
  programming works, and is documented that way in the Atmel AVR
  datasheets.
  In order to successfully program the EEPROM that way, a prior chip
  erase (with the EESAVE fuse unprogrammed) is required.
  This also applies to the STK500 and STK600 in high-voltage programming mode.

* 
  Problem: How do I turn off the `DWEN` fuse?

  Solution: If the `DWEN` (debugWire enable) fuse is activated,
  the `/RESET` pin is not functional anymore, so normal ISP
  communication cannot be established.
  There are two options to deactivate that fuse again: high-voltage
  programming, or getting the JTAG ICE mkII talk debugWire, and
  prepare the target AVR to accept normal ISP communication again.

  The first option requires a programmer that is capable of high-voltage
  programming (either serial or parallel, depending on the AVR device),
  for example the STK500.  In high-voltage programming mode, the
  `/RESET` pin is activated initially using a 12 V pulse (thus the
  name *high voltage*), so the target AVR can subsequently be
  reprogrammed, and the `DWEN` fuse can be cleared.  Typically, this
  operation cannot be performed while the AVR is located in the target
  circuit though.

  The second option requires a JTAG ICE mkII that can talk the debugWire
  protocol.  The ICE needs to be connected to the target using the
  JTAG-to-ISP adapter, so the JTAG ICE mkII can be used as a debugWire
  initiator as well as an ISP programmer.  AVRDUDE will then be activated
  using the `jtag2isp` programmer type.  The initial ISP
  communication attempt will fail, but AVRDUDE then tries to initiate a
  debugWire reset.  When successful, this will leave the target AVR in a
  state where it can accept standard ISP communication.  The ICE is then
  signed off (which will make it signing off from the USB as well), so
  AVRDUDE has to be called again afterwards.  This time, standard ISP
  communication can work, so the `DWEN` fuse can be cleared.

  The pin mapping for the JTAG-to-ISP adapter is:

  @multitable @columnfractions .2 .2
* @strong{JTAG pin} @tab @strong{ISP pin}
* 1 @tab 3
* 2 @tab 6
* 3 @tab 1
* 4 @tab 2
* 6 @tab 5
* 9 @tab 4
  @end multitable

* 
  Problem: Multiple USBasp or USBtinyISP programmers connected simultaneously are not
  found.

  Solution: The USBtinyISP code supports distinguishing multiple
  programmers based on their bus:device connection tuple that describes
  their place in the USB hierarchy on a specific host.  This tuple can
  be added to the `-P usb` option, similar to adding a serial number
  on other USB-based programmers.

  The actual naming convention for the bus and device names is
  operating-system dependent; AVRDUDE will print out what it found
  on the bus when running it with (at least) one `-v` option.
  By specifying a string that cannot match any existing device
  (for example, `-P usb:xxx`), the scan will list all possible
  candidate devices found on the bus.

  Examples:
  ::

    avrdude -c usbtiny -p atmega8 -P usb:003:025 (Linux)
    avrdude -c usbtiny -p atmega8 -P usb:/dev/usb:/dev/ugen1.3 (FreeBSD 8+)
    avrdude -c usbtiny -p atmega8 \\
      -P usb:bus-0:\\\\.\\libusb0-0001--0x1781-0x0c9f (Windows)
    

* 
  Problem: I cannot do ... when the target is in debugWire mode.

  Solution: debugWire mode imposes several limitations.

  The debugWire protocol is Atmel's proprietary one-wire (plus ground)
  protocol to allow an in-circuit emulation of the smaller AVR devices,
  using the `/RESET` line.
  DebugWire mode is initiated by activating the `DWEN`
  fuse, and then power-cycling the target.
  While this mode is mainly intended for debugging/emulation, it
  also offers limited programming capabilities.
  Effectively, the only memory areas that can be read or programmed
  in this mode are flash ROM and EEPROM.
  It is also possible to read out the signature.
  All other memory areas cannot be accessed.
  There is no
  *chip erase*
  functionality in debugWire mode; instead, while reprogramming the
  flash ROM, each flash ROM page is erased right before updating it.
  This is done transparently by the JTAG ICE mkII (or AVR Dragon).
  The only way back from debugWire mode is to initiate a special
  sequence of commands to the JTAG ICE mkII (or AVR Dragon), so the
  debugWire mode will be temporarily disabled, and the target can
  be accessed using normal ISP programming.
  This sequence is automatically initiated by using the JTAG ICE mkII
  or AVR Dragon in ISP mode, when they detect that ISP mode cannot be
  entered.

* 
  Problem: I want to use my JTAG ICE mkII to program an
  Xmega device through PDI.  The documentation tells me to use the
  *XMEGA PDI adapter for JTAGICE mkII* that is supposed to ship
  with the kit, yet I don't have it.

  Solution: Use the following pin mapping:

  @multitable @columnfractions .2 .2 .2 .2
* @strong{JTAGICE} @tab @strong{Target} @tab @strong{Squid cab-} @tab @strong{PDI}
* @strong{mkII probe} @tab @strong{pins} @tab @strong{le colors} @tab @strong{header}
* 1 (TCK)   @tab         @tab Black  @tab
* 2 (GND)   @tab GND     @tab White  @tab 6
* 3 (TDO)   @tab         @tab Grey   @tab
* 4 (VTref) @tab VTref   @tab Purple @tab 2
* 5 (TMS)   @tab         @tab Blue   @tab
* 6 (nSRST) @tab PDI_CLK @tab Green  @tab 5
* 7 (N.C.)  @tab         @tab Yellow @tab
* 8 (nTRST) @tab         @tab Orange @tab
* 9 (TDI)   @tab PDI_DATA @tab Red   @tab 1
* 10 (GND)  @tab         @tab Brown  @tab
  @end multitable

* 
  Problem: I want to use my AVR Dragon to program an
  Xmega device through PDI.  

  Solution: Use the 6 pin ISP header on the Dragon and the following pin mapping:

  @multitable @columnfractions .2 .2
* @strong{Dragon} @tab @strong{Target}
* @strong{ISP Header} @tab @strong{pins}
* 1 (MISO)  @tab PDI_DATA
* 2 (VCC)   @tab VCC
* 3 (SCK)   @tab
* 4 (MOSI)  @tab
* 5 (RESET) @tab PDI_CLK / RST
* 6 (GND)   @tab GND
  @end multitable

* 
  Problem: I want to use my AVRISP mkII to program an
  ATtiny4/5/9/10 device through TPI.  How to connect the pins?

  Solution: Use the following pin mapping:

  @multitable @columnfractions .2 .2 .2
* @strong{AVRISP} @tab @strong{Target} @tab @strong{ATtiny}
* @strong{connector} @tab @strong{pins} @tab @strong{pin #}
* 1 (MISO)  @tab TPIDATA  @tab 1
* 2 (VTref) @tab Vcc      @tab 5
* 3 (SCK)   @tab TPICLK   @tab 3
* 4 (MOSI)  @tab          @tab
* 5 (RESET) @tab /RESET   @tab 6
* 6 (GND)   @tab GND      @tab 2
  @end multitable

* 
  Problem: I want to program an ATtiny4/5/9/10 device using a serial/parallel 
  bitbang programmer.  How to connect the pins?

  Solution: Since TPI has only 1 pin for bi-directional data transfer, both 
  `MISO` and `MOSI` pins should be connected to the `TPIDATA` pin 
  on the ATtiny device.
  However, a 1K resistor should be placed between the `MOSI` and `TPIDATA`.
  The `MISO` pin connects to `TPIDATA` directly.
  The `SCK` pin is connected to `TPICLK`.

  In addition, the `Vcc`, `/RESET` and `GND` pins should 
  be connected to their respective ports on the ATtiny device.

* 
  Problem: How can I use a FTDI FT232R USB-to-Serial device for bitbang programming?

  Solution: When connecting the FT232 directly to the pins of the target Atmel device, 
  the polarity of the pins defined in the `programmer` definition should be 
  inverted by prefixing a tilde. For example, the `dasa` programmer would 
  look like this when connected via a FT232R device (notice the tildes in 
  front of pins 7, 4, 3 and 8):

  ::

    programmer
      id    = "dasa_ftdi";
      desc  = "serial port banging, reset=rts sck=dtr mosi=txd miso=cts";
      type  = serbb;
      reset = ~7;
      sck   = ~4;
      mosi  = ~3;
      miso  = ~8;
    ;
    

  Note that this uses the FT232 device as a normal serial port, not using the 
  FTDI drivers in the special bitbang mode.

* 
  Problem: My ATtiny4/5/9/10 reads out fine, but any attempt to program
  it (through TPI) fails.  Instead, the memory retains the old contents.

  Solution: Mind the limited programming supply voltage range of these
  devices.

  In-circuit programming through TPI is only guaranteed by the datasheet
  at Vcc = 5 V.

* 
  Problem: My ATxmega...A1/A2/A3 cannot be programmed through PDI with
  my AVR Dragon.  Programming through a JTAG ICE mkII works though, as does
  programming through JTAG.

  Solution: None by this time (2010 Q1).

  It is said that the AVR Dragon can only program devices from the A4
  Xmega sub-family.

* 
  Problem: when programming with an AVRISPmkII or STK600, AVRDUDE hangs
  when programming files of a certain size (e.g. 246 bytes).  Other
  (larger or smaller) sizes work though.

  Solution: This is a bug caused by an incorrect handling of zero-length
  packets (ZLPs) in some versions of the libusb 0.1 API wrapper that ships
  with libusb 1.x in certain Linux distributions.  All Linux systems with
  kernel versions < 2.6.31 and libusb >= 1.0.0 < 1.0.3 are reported to be
  affected by this.

  See also: `http://www.libusb.org/ticket/6 <http://www.libusb.org/ticket/6>`_

* 
  Problem: after flashing a firmware that reduces the target's clock
  speed (e.g. through the `CLKPR` register), further ISP connection
  attempts fail.

  Solution: Even though ISP starts with pulling `/RESET` low, the
  target continues to run at the internal clock speed as defined by the
  firmware running before.  Therefore, the ISP clock speed must be
  reduced appropriately (to less than 1/4 of the internal clock speed)
  using the -B option before the ISP initialization sequence will
  succeed.

  As that slows down the entire subsequent ISP session, it might make
  sense to just issue a *chip erase* using the slow ISP clock
  (option `-e`), and then start a new session at higher speed.
  Option `-D` might be used there, to prevent another unneeded
  erase cycle.


